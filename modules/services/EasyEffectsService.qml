pragma Singleton

import QtQuick
import Quickshell
import Quickshell.Io

Singleton {
    id: root

    // Whether EasyEffects is available on the system
    property bool available: false
    
    // Bypass state: false = effects active, true = bypassed
    property bool bypassed: false
    
    // Available presets
    property var outputPresets: []
    property var inputPresets: []
    
    // Currently active presets
    property string activeOutputPreset: ""
    property string activeInputPreset: ""

    // Toggle bypass state
    function toggleBypass() {
        bypassToggleProcess.command = ["easyeffects", "-b", bypassed ? "2" : "1"];
        bypassToggleProcess.running = true;
    }
    
    function setBypass(enable: bool) {
        bypassToggleProcess.command = ["easyeffects", "-b", enable ? "1" : "2"];
        bypassToggleProcess.running = true;
    }

    // Load a preset
    function loadPreset(name: string) {
        loadPresetProcess.command = ["easyeffects", "-l", name];
        loadPresetProcess.running = true;
    }

    // Refresh all data
    function refresh() {
        checkAvailableProcess.running = true;
    }

    // Open EasyEffects app
    function openApp() {
        openAppProcess.running = true;
    }

    // Check if easyeffects is available
    Process {
        id: checkAvailableProcess
        command: ["which", "easyeffects"]
        running: true
        onExited: (exitCode, exitStatus) => {
            root.available = (exitCode === 0);
            if (root.available) {
                // Fetch initial state
                bypassStateProcess.running = true;
                presetsProcess.running = true;
                activePresetsProcess.running = true;
            }
        }
    }

    // Get bypass state
    Process {
        id: bypassStateProcess
        command: ["easyeffects", "-b", "3"]
        running: false
        environment: ({ LANG: "C", LC_ALL: "C" })
        stdout: SplitParser {
            onRead: data => {
                const val = data.trim();
                root.bypassed = (val === "1");
            }
        }
    }

    // Toggle bypass
    Process {
        id: bypassToggleProcess
        running: false
        onExited: {
            bypassStateProcess.running = true;
        }
    }

    // Load preset
    Process {
        id: loadPresetProcess
        running: false
        onExited: {
            // Refresh active presets after loading
            activePresetsProcess.running = true;
        }
    }

    // List presets
    Process {
        id: presetsProcess
        command: ["easyeffects", "-p"]
        running: false
        property string buffer: ""
        environment: ({ LANG: "C", LC_ALL: "C" })
        stdout: SplitParser {
            onRead: data => {
                presetsProcess.buffer += data + "\n";
            }
        }
        onExited: {
            const text = presetsProcess.buffer;
            presetsProcess.buffer = "";
            
            const lines = text.split("\n");
            let isOutput = false;
            let isInput = false;
            let outputList = [];
            let inputList = [];
            
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed.toLowerCase().includes("output")) {
                    isOutput = true;
                    isInput = false;
                    // Check if presets are on same line after colon
                    const parts = trimmed.split(":");
                    if (parts.length > 1 && parts[1].trim()) {
                        outputList = parts[1].trim().split(",").map(p => p.trim()).filter(p => p);
                    }
                } else if (trimmed.toLowerCase().includes("input")) {
                    isInput = true;
                    isOutput = false;
                    const parts = trimmed.split(":");
                    if (parts.length > 1 && parts[1].trim()) {
                        inputList = parts[1].trim().split(",").map(p => p.trim()).filter(p => p);
                    }
                } else if (trimmed && !trimmed.includes(":")) {
                    // Preset name on its own line
                    if (isOutput) outputList.push(trimmed);
                    else if (isInput) inputList.push(trimmed);
                }
            }
            
            root.outputPresets = outputList;
            root.inputPresets = inputList;
        }
    }

    // Get active presets
    Process {
        id: activePresetsProcess
        command: ["easyeffects", "-a"]
        running: false
        property string buffer: ""
        environment: ({ LANG: "C", LC_ALL: "C" })
        stdout: SplitParser {
            onRead: data => {
                activePresetsProcess.buffer += data + "\n";
            }
        }
        onExited: {
            const text = activePresetsProcess.buffer;
            activePresetsProcess.buffer = "";
            
            const lines = text.split("\n");
            for (const line of lines) {
                const trimmed = line.trim().toLowerCase();
                if (trimmed.includes("output")) {
                    const parts = line.split(":");
                    if (parts.length > 1) {
                        root.activeOutputPreset = parts[1].trim();
                    }
                } else if (trimmed.includes("input")) {
                    const parts = line.split(":");
                    if (parts.length > 1) {
                        root.activeInputPreset = parts[1].trim();
                    }
                }
            }
        }
    }

    // Open app
    Process {
        id: openAppProcess
        command: ["easyeffects"]
        running: false
    }

    // Poll for state changes periodically
    Timer {
        interval: 5000
        running: root.available
        repeat: true
        onTriggered: {
            bypassStateProcess.running = true;
            activePresetsProcess.running = true;
        }
    }
}
